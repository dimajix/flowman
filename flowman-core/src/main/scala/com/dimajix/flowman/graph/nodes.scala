/*
 * Copyright 2021-2022 Kaya Kupferschmidt
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

package com.dimajix.flowman.graph

import scala.collection.mutable

import com.dimajix.flowman.execution.Phase
import com.dimajix.flowman.model.Mapping
import com.dimajix.flowman.model.Relation
import com.dimajix.flowman.model.ResourceIdentifier
import com.dimajix.flowman.model.Target


sealed abstract class Node extends Product with Serializable {
    private[graph] val inEdges = mutable.Buffer[Edge]()
    private[graph] val outEdges = mutable.Buffer[Edge]()
    private[graph] val _parent : Option[Node] = None
    private[graph] val _children = mutable.Seq[Node]()

    /** Unique node ID, generated by GraphBuilder */
    val id : Int

    def label : String = s"($id) ${category.lower}/$kind: '$name'"

    def category : Category
    def kind : String
    def name : String

    def provides : Set[ResourceIdentifier]
    def requires : Set[ResourceIdentifier]

    /**
     * List of incoming edges, i.e. the upstream nodes which provide input data
     * @return
     */
    def incoming : Seq[Edge] = inEdges

    /**
     * List of outgoing edges, i.e. downstream nodes which receive data from this node
     * @return
     */
    def outgoing : Seq[Edge] = outEdges

    /**
     * Child nodes providing more detail. For example a "Mapping" node might contain detail information on individual
     * columns, which would be logical children of the mapping.
     * @return
     */
    def children : Seq[Node] = _children

    /**
     * Optional parent node. For example a "Column" node might be a child of a "Mapping" node
     * @return
     */
    def parent : Option[Node] = _parent

    /**
     * Create a nice string representation of the upstream dependency tree
     * @return
     */
    def upstreamDependencyTree : String = {
        label + "\n" + upstreamTreeRec
    }

    private def upstreamTreeRec : String = {
        def indentSubtree(lines:Iterator[String], margin:Boolean) : Iterator[String] = {
            if (lines.nonEmpty) {
                val prefix = if (margin) "  |  " else "     "
                val firstLine = "  +- " + lines.next()
                Iterator(firstLine) ++ lines.map(prefix + _)
            }
            else {
                Iterator()
            }
        }
        val trees = incoming.map { child =>
            child.label + "\n" + child.input.upstreamTreeRec
        }
        val headChildren = trees.dropRight(1)
        val lastChild = trees.takeRight(1)

        val headTree = headChildren.flatMap(l => indentSubtree(l.linesIterator, true))
        val tailTree = lastChild.flatMap(l => indentSubtree(l.linesIterator, false))
        (headTree ++ tailTree).mkString("\n")
    }
}

final case class MappingRef(id:Int, mapping:Mapping) extends Node {
    override def category: Category = Category.MAPPING
    override def kind: String = mapping.kind
    override def name: String = mapping.name
    override def provides : Set[ResourceIdentifier] = Set()
    override def requires : Set[ResourceIdentifier] = mapping.requires
}
final case class TargetRef(id:Int, target:Target, phase:Phase) extends Node {
    override def category: Category = Category.TARGET
    override def kind: String = target.kind
    override def name: String = target.name
    override def provides : Set[ResourceIdentifier] = target.provides(phase)
    override def requires : Set[ResourceIdentifier] = target.requires(phase)
}
final case class RelationRef(id:Int, relation:Relation) extends Node {
    override def category: Category = Category.RELATION
    override def kind: String = relation.kind
    override def name: String = relation.name
    override def provides : Set[ResourceIdentifier] = relation.provides
    override def requires : Set[ResourceIdentifier] = relation.requires
}

final case class MappingColumn(id:Int, mapping: Mapping, output:String, column:String) extends Node {
    override def category: Category = Category.MAPPING_COLUMN
    override def kind: String = "mapping_column"
    override def name: String = mapping.name + "." + output + "." + column
    override def provides : Set[ResourceIdentifier] = Set()
    override def requires : Set[ResourceIdentifier] = Set()
}
final case class RelationColumn(id:Int, relation: Relation, column:String) extends Node {
    override def category: Category = Category.RELATION_COLUMN
    override def kind: String = "relation_column"
    override def name: String = relation.name + "." + column
    override def provides : Set[ResourceIdentifier] = Set()
    override def requires : Set[ResourceIdentifier] = Set()
}
